## ---------------------------------------------- ##
        # WRTDS - Explore Window Argument(s)
## ---------------------------------------------- ##
# WRTDS = Weighted Regressions on Time, Discharge, and Season
## Nick J Lyon

## ---------------------------------------------- ##
                # Housekeeping ----
## ---------------------------------------------- ##
# Load libraries
# install.packages("librarian")
librarian::shelf(tidyverse, googledrive, lubridate, EGRET, EGRETci, lter/HERON, njlyon0/helpR)

# Clear environment
rm(list = ls())

# If working on server, need to specify correct path
(path <- scicomptools::wd_loc(local = FALSE, remote_path = file.path('/', "home", "shares", "lter-si", "WRTDS")))

# Read in CSVs generated by 'step-2' script
discharge <- read.csv(file.path(path, "WRTDS Inputs", "WRTDS-input_discharge.csv"))
chemistry <- read.csv(file.path(path, "WRTDS Inputs", "WRTDS-input_chemistry.csv"))
information <- read.csv(file.path(path, "WRTDS Inputs", "WRTDS-input_information.csv"))

# Filter these to only the desired rivers
disc_simp <- discharge %>%
  dplyr::filter(Stream_ID %in% c("Finnish Environmental Institute__KEMIJOKI ISOHAARA 14000",
                                 "GRO__Yenisey"))
chem_simp <- chemistry %>%
  dplyr::filter(Stream_Element_ID %in% c(
    "Finnish Environmental Institute__KEMIJOKI ISOHAARA 14000_NH4",
    "GRO__Yenisey_DSi", "GRO__Yenisey_NOx"))
info_simp <- information %>%
  dplyr::filter(Stream_ID %in% c("Finnish Environmental Institute__KEMIJOKI ISOHAARA 14000",
                                 "GRO__Yenisey"))

## ---------------------------------------------- ##
              # Analysis Workflow ----
## ---------------------------------------------- ##

# Loop across rivers and elements to run WRTDS workflow!
# for(river in chem_simp$Stream_Element_ID){
for(river in "GRO__Yenisey_NOx"){
  
  # Identify corresponding Stream_ID
  stream_id <- chem_simp %>%
    dplyr::filter(Stream_Element_ID == river) %>%
    dplyr::select(Stream_ID) %>%
    unique() %>%
    as.character()
  
  # Also element
  element <- chem_simp %>%
    dplyr::filter(Stream_Element_ID == river) %>%
    dplyr::select(variable) %>%
    unique() %>%
    as.character()
  
  # Subset chemistry
  river_chem <- chem_simp %>%
    dplyr::filter(Stream_Element_ID == river) %>%
    # Drop unneeded columns
    dplyr::select(-Stream_Element_ID, -Stream_ID, -variable)
  
  # Subset discharge to correct river
  river_disc <- disc_simp %>%
    dplyr::filter(Stream_ID == stream_id) %>%
    dplyr::select(Date, Q)
  
  # Create a common prefix for all outputs from this run of the loop
  out_prefix <- paste0(stream_id, "_", element, "_") 
  
  # Message completion of loop
  message("Processing begun for '", element, "' at stream '", stream_id, "'")
  
  # Information also subsetted to right river
  river_info <- info_simp %>%
    dplyr::filter(Stream_ID == stream_id) %>%
    # Generate correct information for this element
    dplyr::mutate(constitAbbrev = element) %>%
    dplyr::mutate(paramShortName = dplyr::case_when(
      constitAbbrev == "DSi" ~ "Silicon",
      constitAbbrev == "NOx" ~ "Nitrate_NOx",
      constitAbbrev == "NO3" ~ "Nitrate_NO3",
      constitAbbrev == "P" ~ "Phosphorous",
      constitAbbrev == "NH4" ~ "Ammonium",
      constitAbbrev == "TP" ~ "Total_Phosphorous",
      constitAbbrev == "TN" ~ "Total_Nitrogen")) %>%
    # Create another needed column
    dplyr::mutate(staAbbrev = shortName) %>%
    # Drop stream ID now that subsetting is complete
    dplyr::select(-Stream_ID)
  
  # Save these as CSVs with generic names
  ## This means each iteration of the loop will overwrite them so this folder won't become gigantic
  write.csv(x = river_disc, row.names = F, na = "",
            file = file.path(path, "WRTDS Temporary Files", "discharge.csv"))
  write.csv(x = river_chem, row.names = F, na = "",
            file = file.path(path, "WRTDS Temporary Files", "chemistry.csv"))
  write.csv(x = river_info, row.names = F, na = "",
            file = file.path(path, "WRTDS Temporary Files", "information.csv"))
  
  # Then read them back in with EGRET's special acquisition functions
  egret_disc <- EGRET::readUserDaily(filePath = file.path(path, "WRTDS Temporary Files"), fileName = "discharge.csv", qUnit = 2, verbose = F)
  egret_chem <- EGRET::readUserSample(filePath = file.path(path, "WRTDS Temporary Files"), fileName = "chemistry.csv", verbose = F)
  egret_info <- EGRET::readUserInfo(filePath = file.path(path, "WRTDS Temporary Files"), fileName = "information.csv", interactive = F)
  
  # Create a list of the discharge, chemistry, and information files
  egret_list <- EGRET::mergeReport(INFO = egret_info, Daily = egret_disc, Sample = egret_chem, verbose = F)
  
  # Fit "GFN" model
  egret_list_out <- EGRET::runSeries(eList = egret_list, windowSide = 11, minNumObs = 50, verbose = F)
  
  # Fit original model
  egret_estimation <- EGRET::modelEstimation(eList = egret_list, minNumObs = 50, verbose = F)
  
  # Create PDF report of preliminary graphs
  HERON::egret_report(eList_estim = egret_estimation, eList_series = egret_list_out,
                      out_path = file.path(path, "WRTDS Outputs", paste0(out_prefix, "WRTDS_GFN_output.pdf")))
  
  # Message completion of loop
  message("Processing complete for '", element, "' at stream '", stream_id, "'")
  
} # End loop

# End ----
