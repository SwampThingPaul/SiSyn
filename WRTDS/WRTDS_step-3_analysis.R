## ---------------------------------------------- ##
           # WRTDS Centralized Workflow
## ---------------------------------------------- ##
# WRTDS = Weighted Regressions on Time, Discharge, and Season
## Nick J Lyon

## ---------------------------------------------- ##
                # Housekeeping ----
## ---------------------------------------------- ##
# Load libraries
# install.packages("librarian")
librarian::shelf(tidyverse, googledrive, lubridate, EGRET, EGRETci, njlyon0/helpR)

# Clear environment
rm(list = ls())

# If working on server, need to specify correct path
(path <- scicomptools::wd_loc(local = FALSE, remote_path = file.path('/', "home", "shares", "lter-si", "WRTDS")))

# Read in CSVs generated by 'step-2' script
discharge <- read.csv(file.path(path, "WRTDS Inputs", "WRTDS-input_discharge.csv"))
chemistry <- read.csv(file.path(path, "WRTDS Inputs", "WRTDS-input_chemistry.csv"))
information <- read.csv(file.path(path, "WRTDS Inputs", "WRTDS-input_information.csv"))

## ---------------------------------------------- ##
           # WRTDS - Standard Workflow ----
## ---------------------------------------------- ##
# Structure:
## Big for loop that iterates across "Stream_Name" names
## Within that loop, a smaller loop iterates across chemicals sampled there

# Drop problem rivers from the loop
bad_rivers <- c(
  # Error in `EGRET::modelEstimation`
  ### "Error in runSurvReg(SampleCrossV$DecYear[i], SampleCrossV$LogQ[i], DecLow,  : 
  ### minNumUncen is greater than total number of samples"
  "AND__GSWS06_NOx", "AND__GSWS07_NOx", "HBR__ws1_P", "HBR__ws2_P", "HBR__ws3_P",
  "HBR__ws4_P", "HBR__ws5_P", "HBR__ws6_P", "HBR__ws7_P", "HBR__ws8_P", "HBR__ws9_P",
  "MCM__Canada Stream at F1_P", "MCM__Onyx River at Lake Vanda Weir_NH4",
  "MCM__Onyx River at Lake Vanda Weir_P", "MCM__Onyx River at Lower Wright Weir_P",
  "NIVA__AAGEVEG_DSi", "NIVA__FINEPAS_DSi", "NIVA__FINETAN_DSi", "NIVA__HOREVOS_DSi",
  "NIVA__MROEDRI_DSi", "NIVA__OSLEALN_DSi", "NIVA__ROGEBJE_DSi", "NIVA__ROGEVIK_DSi",
  "NIVA__SFJENAU_DSi", "NIVA__STRENID_DSi", 
  # Warning in `EGRET::mergeReport`
  ### "Some Sample dates do not have corresponding flow data. Not all EGRET functions will work correctly."
  # Warning in ` EGRET::modelEstimation`
  ### "Problems converging"
  # Eventual downstream error message:
  ### "Error in if (lastMonth == 2 & (lastYear%%4 == 0) & ((lastYear%%100 !=  : 
  ### missing value where TRUE/FALSE needed"
  "LUQ__RI_DSi", "LUQ__RI_NH4", "LUQ__RI_NOx", "LUQ__RI_P",
  # Warning about "duplicated Daily dates" and "duplicated Sample dates"
  ### "Error in seq.Date(surfaceStart, by = "1 year", length.out = nSeg) : 
  ###'from' must be of length 1"
  "USGS__Wild River_DSi")

# Loop across rivers and elements to run WRTDS workflow!
for(river in setdiff(x = unique(chemistry$Stream_Element_ID), y = bad_rivers)){
  # (^^^) Actual loop (uncomment when you are ready)
  # (vvv) Test loop for a single site
  # for(river in "AND__GSWS02_DSi"){
  
  # Identify corresponding Stream_ID
  stream_id <- chemistry %>%
    dplyr::filter(Stream_Element_ID == river) %>%
    dplyr::select(Stream_ID) %>%
    unique() %>%
    as.character()
  
  # Also element
  element <- chemistry %>%
    dplyr::filter(Stream_Element_ID == river) %>%
    dplyr::select(variable) %>%
    unique() %>%
    as.character()
  
  # Subset chemistry
  river_chem <- chemistry %>%
    dplyr::filter(Stream_Element_ID == river) %>%
    # Drop unneeded columns
    dplyr::select(-Stream_Element_ID, -Stream_ID, -variable)
  
  # Subset discharge to correct river
  river_disc <- discharge %>%
    dplyr::filter(Stream_ID == stream_id) %>%
    dplyr::select(Date, Q)
  
  # Create a common prefix for all outputs from this run of the loop
  out_prefix <- paste0(stream_id, "_", element, "_") 
  
  # If the file exists
  if(file.exists(file.path(path, "WRTDS Loop Diagnostic", paste0(out_prefix, "Loop_Diagnostic.csv"))) == TRUE) {
    message("WRTDS already run for ", element, " at stream '", river, "'")
  } else {
    
    # Message completion of loop
    message("Processing begun for ", element, " at stream '", river, "'")
    
    # Grab start time for processing
    start <- Sys.time()
    
    # Information also subsetted to right river
    river_info <- information %>%
      dplyr::filter(Stream_ID == stream_id) %>%
      # Generate correct information for this element
      dplyr::mutate(constitAbbrev = element) %>%
      dplyr::mutate(paramShortName = dplyr::case_when(
        constitAbbrev == "DSi" ~ "Silicon",
        constitAbbrev == "NOx" ~ "Nitrate",
        constitAbbrev == "P" ~ "Phosphorous",
        constitAbbrev == "NH4" ~ "Ammonium")) %>%
      # Create another needed column
      dplyr::mutate(staAbbrev = shortName) %>%
      # Drop stream ID now that subsetting is complete
      dplyr::select(-Stream_ID)
    
    # Save these as CSVs with generic names
    ## This means each iteration of the loop will overwrite them so this folder won't become gigantic
    write.csv(x = river_disc, row.names = F, na = "",
              file = file.path(path, "WRTDS Temporary Files", "discharge.csv"))
    write.csv(x = river_chem, row.names = F, na = "",
              file = file.path(path, "WRTDS Temporary Files", "chemistry.csv"))
    write.csv(x = river_info, row.names = F, na = "",
              file = file.path(path, "WRTDS Temporary Files", "information.csv"))
    
    # Then read them back in with EGRET's special acquisition functions
    egret_disc <- EGRET::readUserDaily(filePath = file.path(path, "WRTDS Temporary Files"), fileName = "discharge.csv", qUnit = 2, verbose = F)
    egret_chem <- EGRET::readUserSample(filePath = file.path(path, "WRTDS Temporary Files"), fileName = "chemistry.csv", verbose = F)
    egret_info <- EGRET::readUserInfo(filePath = file.path(path, "WRTDS Temporary Files"), fileName = "information.csv", interactive = F)
    
    # Create a list of the discharge, chemistry, and information files
    egret_list <- EGRET::mergeReport(INFO = egret_info, Daily = egret_disc, Sample = egret_chem, verbose = F)
    
    # Fit original model
    egret_estimation <- EGRET::modelEstimation(eList = egret_list, minNumObs = 50, verbose = F)
    
    # Fit "GFN" model
    egret_list_out <- EGRET::runSeries(eList = egret_list, windowSide = 11, minNumObs = 50, verbose = F)
    
    # Identify error statistics
    egret_error <- EGRET::errorStats(eList = egret_estimation)
    
    # Save the error stats out
    write.csv(x = egret_error, file = file.path(path, "WRTDS Outputs", paste0(out_prefix, "ErrorStats_WRTDS.csv")), row.names = F, na = "")
    
    # Create PDF report
    ## Start the PDF
    pdf(file = file.path(path, "WRTDS Outputs", paste0(out_prefix, "WRTDS_GFN_output.pdf")))
    
    ## Residual plots
    EGRET::fluxBiasMulti(eList = egret_estimation)
    
    ## Model Fit
    EGRET::plotConcTimeDaily(eList = egret_list_out)
    
    ## Concentration
    EGRET::plotConcHist(eList = egret_list_out) # minYP, maxYP)
    
    ## Flux
    EGRET::plotFluxHist(eList = egret_list_out) #, minYP, maxYP)
    
    ## Data
    EGRET::multiPlotDataOverview(eList = egret_list_out)
    
    ## Actually create PDF report
    dev.off()
    
    # Create annual averages
    egret_annual <- EGRET::tableResults(eList = egret_list_out)
    ## Can't silence this function... >:(
    
    # Export that as a CSV also
    write.csv(x = egret_annual, file.path(path, "WRTDS Outputs", paste0(out_prefix, "ResultsTable_GFN_WRTDS.csv")), row.names = F, na = "")
    
    # Identify monthly results
    egret_monthly <- EGRET::calculateMonthlyResults(eList = egret_list_out)
    
    # Export that
    write.csv(x = egret_monthly, file.path(path, "WRTDS Outputs", paste0(out_prefix, "Monthly_GFN_WRTDS.csv")), row.names = F, na = "")
    
    # Extract daily chemical value from run
    egret_concentration <- egret_list_out$Daily
    
    # Export that as well
    write.csv(x = egret_concentration, file.path(path, "WRTDS Outputs", paste0(out_prefix, "GFN_WRTDS.csv")), row.names = F, na = "")
    
    # Make a new column for year
    egret_concentration$Year <- format(as.Date(egret_concentration$Date), "%Y")
    
    # Find min & max year
    min_year <- as.numeric(min(egret_concentration$Year, na.rm = T)) + 1
    max_year <- as.numeric(max(egret_concentration$Year, na.rm = T)) - 1
    
    # Set them as a vector
    year_points <- c(min_year, max_year)
    
    # Calculate concentration trend
    egret_conc_trend_v1 <- EGRET::tableChangeSingle(eList = egret_list_out, fluxUnit = 8, yearPoints = year_points, flux = FALSE)
    ## Can't silence this function either
    
    # Calculate flux trend
    egret_flux_trend <- EGRET::tableChangeSingle(eList = egret_list_out, fluxUnit = 8, yearPoints = year_points, flux = TRUE)
    ## Can't silence this function either
    
    # Add a column to each of these indicating whether it's flux or conc.
    egret_conc_trend_v1$Metric <- "Concentration"
    egret_flux_trend$Metric <- "Flux"
    
    # Rename two columns in the concentration dataframe
    egret_conc_trend <- egret_conc_trend_v1 %>%
      dplyr::rename(`change[percent]` = `change[%]`,
                    `slope [percent/yr]` = `slope [%/yr]`)
    
    # Bind these dataframes together
    egret_trends <- egret_conc_trend %>%
      dplyr::bind_rows(egret_flux_trend) %>%
      # Move the metric column before everything else
      dplyr::select(Metric, dplyr::everything())
    
    # Export it!
    write.csv(x = egret_trends, file.path(path, "WRTDS Outputs", paste0(out_prefix, "TrendsTable_GFN_WRTDS.csv")), row.names = F, na = "")
    
    # Grab the end processing time
    end <- Sys.time()
    
    # Combine timing into a dataframe
    loop_diagnostic <- data.frame("stream" = stream_id,
                                  "chemical" = element,
                                  "loop_start" = start,
                                  "loop_end" = end)
    
    # Export this as well
    write.csv(x = loop_diagnostic, file.path(path, "WRTDS Loop Diagnostic", paste0(out_prefix, "Loop_Diagnostic.csv")), row.names = F, na = "")
    
    # Message completion of loop
    message("Processing complete for ", element, " at stream '", river, "'")
    
  } # Close `else` part of whether file exists
  
} # End loop

# End ----
